# Полиморфизм

Полиморфизм в С++ - это возможность объектов разных классов обладать одинаковыми именами функций, но с разными реализациями. 

Статический тип в С++ определяется на этапе компиляции и является типом переменной или выражения в коде. Динамический тип, с другой стороны, определяется во время выполнения программы и может изменяться в зависимости от того, какой объект был назначен переменной.

Пример:

```c++
class Animal {
};

class Dog : public Animal {
};

class Cat : public Animal {
};


Animal* animal = new Dog();
// статический тип animal - Animal*
// динамический тип animal - Dog*

Animal* animal2 = new Cat();
// статический тип animal2 - Animal*
// динамический тип animal2 - Cat*
```

В этом примере переменные `animal` и `animal2` имеют одинаковый статический тип - `Animal*`. Однако, динамический тип каждой переменной зависит от того, какой объект был назначен ей во время выполнения программы.

Динамический тип нельзя определить на этапе компиляции, просто посмотрите на пример:

```c++
int n;
std::cin >> n;

Animal* ptr = 0;
auto c = Cat();
auto d = Dog();
if (n >= 0) {
    ptr = &c;
} else {
    ptr = &d;
}
```

Компилтор не знает, какое `n` будет на входе, поэтому и не может определить реальный тип объекта под указателем.


Расширим функционал классов:

```c++
class Animal {
    void MakeSound() {
        std::cout << "I am an unknown animal(\n";
    }
};

class Dog : public Animal {
    void MakeSound() {
        std::cout << "Dog(\n";
    }
};

class Cat : public Animal {
    void MakeSound() {
        std::cout << "Cat(\n";
    }
};
```

Мы добавили метод `MakeSound` в эти классы, каждый из них выводит свою строку на экран.

```c++
int n;
std::cin >> n;

Animal* ptr = 0;
auto c = Cat();
auto d = Dog();
if (n >= 0) {
    ptr = &c;
} else {
    ptr = &d;
}
ptr->MakeSound();
```

Ввод:
```
100
```
Вывод:
```
I am an unknown animal(
```

Ввод
```
-100
```

Вывод
```
I am an unknown animal(
```


Как и ожидалось, не важно, что именно лежит под адресом, если у указателя тип `Animal*`, то будет вызван метод именно класса `Animal`.

Однако, в некоторый ситуациях, когда вы просите `Animal` издать звук, вы ожидаете какой-то конкретный ответ. Собака - это животное, но если попросить собаку издать голос, она не скажет `I am an unknown animal(`, а закономерно начнет лаять. Также и кот, издаст свой собственный звук, несмотря на то, что он животное.

В этом месте мы переходим к понятию виртуальных методов:

## Виртуальные методы

Виртуальный метод в С++ - это метод базового класса, который может быть переопределен в производных классах и вызываться для объектов производных классов исходя из их динамических типов.

А именно, нужно добавить слово `virtual` перед объявлением метода в базовом классе:

```c++
class Animal {
    virtual void MakeSound() {
        std::cout << "I am an unknown animal(\n";
    }
};

class Dog : public Animal {
    void MakeSound() {
        std::cout << "Dog(\n";
    }
};

class Cat : public Animal {
    void MakeSound() {
        std::cout << "Cat(\n";
    }
};
```

Повторим эксперимент:

```c++
int n;
std::cin >> n;

Animal* ptr = 0;
if (n >= 0) {
    ptr = new Cat();
} else {
    ptr = new Dog();
}
ptr->MakeSound();
```

Ввод:
```
100
```
Вывод:
```
Cat
```

Ввод
```
-100
```

Вывод
```
Dog
```

_хорошей практикой является также добавлять слово override для методов наследников, которые перегружают виртуальные методы базового класса_:
```c++
class Animal {
    virtual void MakeSound() {
        std::cout << "I am an unknown animal(\n";
    }
};

class Dog : public Animal {
    void MakeSound() override {
        std::cout << "Dog(\n";
    }
};

class Cat : public Animal {
    void MakeSound() override {
        std::cout << "Cat(\n";
    }
};
```

## Чисто виртуальные функции

Pure virtual function (чисто виртуальная функция) в С++ - это виртуальный метод базового класса, который не имеет реализации в этом классе и должен быть переопределен в производных классах. 

Чтобы создать такую функцию, необходимо после объявления метода написать ` = 0;`

```c++
class Shape {
public:
    virtual double Area() = 0; // чисто виртуальная функция
};

class Rectangle : public Shape {
private:
    double Width;
    double Height;
public:
    Rectangle(double w, double h) : Width(w), Height(h) {};
    double Area() {
        return Width * Height;
    }
};

class Circle : public Shape {
private:
    double Radius;
public:
    Circle(double radius) : Radius(radius) {};
    double Area() {
        return 3.14 * Radius * Radius;
    }
};

int main() {
    auto r = Rectangle(4, 6);
    Shape* shape = &r;
    std::cout << "Rectangle area: " << shape->Area() << std::endl;
    auto c = Circle(10);
    shape = &c;
    std::cout << "Circle area: " << shape->Area() << std::endl;
}
```

В этом примере, что `Rectangle`, что `Circle` являются фигурами(`Shape`), однако у фигуры определять метод `Area` не совсем корректно.

## Абстрактный класс
Абстрактный класс в С++ - это класс, содержащий хотя бы одну чисто виртуальную функцию (pure virtual function), что делает его невозможным для создания объектов. Такой класс используется как базовый класс для производных классов, которые должны реализовать все чисто виртуальные функции базового класса.

Например, мы не можем создать объект типа `Shape`:
```c++
Shape shape; // CE
```
При этом создавать ссылки с таким типом или же указатели можно
```c++
Circle c;
Shape* shapePtr = &c;
Shape& shapeRef = c;
```

## Проблема виртуального деструктора

Проблема виртуального деструктора в C++ заключается в том, что если у класса есть виртуальные функции и он используется как базовый класс для других классов, то при удалении объектов производных классов через указатель на базовый класс без виртуального деструктора может произойти утечка памяти и не вызовутся деструкторы производных классов.

Решение этой проблемы заключается в том, чтобы объявить деструктор базового класса виртуальным. Это гарантирует, что при удалении объекта через указатель на базовый класс будут вызываться деструкторы всех производных классов в правильном порядке и не будет утечек памяти.

Пример:

```c++
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    ~Derived() {}
};

int main() {
    Base* ptr = new Derived();
    delete ptr
}
```

В этом примере мы создаем объект класса `Derived` и сохраняем его адрес в переменной `ptr` типа `Base*`. Затем мы удаляем объект через указатель на базовый класс, что вызывает деструктор `Base::~Base()` и деструктор `Derived::~Derived()` в правильном порядке.

Обратите внимание, что если бы мы не объявили деструктор `Base::~Base()` виртуальным, то при удалении объекта через указатель на базовый класс вызвался бы только деструктор `Base::~Base()`, а деструктор `Derived::~Derived()` не вызывался бы, что могло привести к утечке памяти.
