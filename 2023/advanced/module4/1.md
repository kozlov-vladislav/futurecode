```
SQRT-декомпозиция
Алгоритм Мо и его модификации
```

SQRT-декомпозиция может встретиться в разных задачах под разным видом. Главный смысл в том, чтобы разделить входные данные на блоки, где размер блока порядка корня, от рамера входных данных.

Предлагается рассмотреть несколько задач на эту тему

_Задача: дан массив размера n, приходит q запросов вида (перевернуть отрезок массива с l по r), и (посчитать сумму на отрезках с l по r)._

Разделим массив на блоки, размера k. В каждом блоке будем хранить сумму элементов в этом блоке и сами элементы. Также будем хранить флаг, правда ли элементы внутри блока лежат в нужном порядке, или же их нужно перевенуть.

Операцию переворачивания будем обрабатывать так:

Смотрим, какие блоки полностью попали в отрезок запроса, слева и справа от них могут быть блоки, который попали не полностью.

Чтобы перевернуть элементы внутри блока, просто запишем в флаг этого блока, что элементы там перевернуты. В тех блоках, которые попали не полностью, честно перевернем ту часть, которая попала в запрос. Также заметим, что недостаточно просто перевернуть элементы внутри блоков, нужно поменять порядок и самих блоков. Чтобы это сделать быстро, будем хранить массив указателей на блоки(или же хранить блоки в массиве, а адреса блоков будут индексы в этом массиве). Когда приходит запрос на переворот, будем переворачивать сами блоки в этом массиве блоков(помимо того, что нужно сделать для самих блоков).

Итого, это работает за 

1. 2 * k -- честно перевернуть элементы в крайних блоках
2. n / k - проставить флаги в блоках
3. n / k - поменять порядок самих блоков.


$$O(k + \frac{n}{k})$$

Как будем отвечать на запрос суммы? Посмотрим, какие блоки полностью попали в запрос, у них спросим полностью сумму, которая уже посчитана для любого блока и хранится вместе с блоком - O(n / k). А для крайних блоков честно пробежимся по элементам и посчитаем сумму - O(2 * k).

$$O(k + \frac{n}{k})$$

Итого, какой k нужно взять? Несложно показать, что самый лучший k здесь будет $k = \sqrt{n}$.

_Стоит отметить, что помимо того, что написано выше, для каждого блока, если мы честно пробегаемся по его элементам, нужно посмотреть на его флаг, и если что перевернуть его элементы_


--------

Есть задачи, где k не является корнем из n, он может быть корнем из n * log(n) или нечто другое, и зависит это от самой задачи. Считаете асимптотику и понимаете, какой k лучше подходит.

--------

Алгоритм МО

Еще 1 вариант декомпозиции, но тут скорее делятся сами запросы, а не массив. Есть отдельный пул задач, которые можно решить с его помощью.

Предлагается разобрать всё отсюда до пункта про деревья(мо на дереве и 3d мо трогать не будем)

[ссылка](https://ru.algorithmica.org/cs/decomposition/mo/)

----------

Еще задачи на разбор

[Задача](https://codeforces.com/contest/13/problem/E)

[Разбор E](https://codeforces.com/blog/entry/364)

-------

[P5](https://codeforces.com/blog/entry/96713)

[Полуразбор](https://wiki.algocode.ru/index.php?title=%D0%9A%D0%BE%D1%80%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BD%D0%B0_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%D1%85)